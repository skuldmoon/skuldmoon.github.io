{"pages":[],"posts":[{"title":"Java循环删除元素","text":"总结一下Java循环删除元素的坑。 首先我们先初始化一个List： 1234List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"a\");list.add(\"b\");list.add(\"c\"); 错误的做法使用增强for循环删除元素12345for (String s : list) &#123; if (\"a\".equals(s)) list.remove(s);&#125;System.out.println(list); 结果报错： 1234java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851) ... 这是因为增强for循环是使用迭代器来实现的，上面的代码完全等同于： 12345for (Iterator&lt;String&gt; i = list.iterator(); i.hasNext();) &#123; String s = i.next(); if (\"a\".equals(s)) list.remove(s);&#125; 问题在于List的remove方法会使modcount++，而迭代器中记录的值并没有变化，所以会出现ConcurrentModificationException异常。 不推荐的做法使用普通for循环删除元素123456for (int i = 0; i &lt; list.size(); i++) &#123; if (\"a\".equals(list.get(i))) &#123; list.remove(list.get(i)); &#125;&#125;System.out.println(list); // [b,c] 使用普通for循环删除单个元素是没有问题的，但是如果删除多个元素，由于数组大小的改变，循环时后面的那个元素会被跳过，如下所示，得到的结果和上面完全一样。 123456for (int i = 0; i &lt; list.size(); i++) &#123; if (\"a\".equals(list.get(i)) || \"b\".equals(list.get(i))) &#123; list.remove(list.get(i)); &#125;&#125;System.out.println(list); // [b,c] 使用iterator循环删除元素使用iterator自带的remove方法删除元素不会出现ConcurrentModificationException异常，但是代码过于繁琐。 123456for (Iterator&lt;String&gt; i = list.iterator(); i.hasNext();) &#123; String s = i.next(); if (\"a\".equals(s) || \"b\".equals(s)) i.remove();&#125;System.out.println(list); // [c] 推荐的做法最简单正确的方法是使用Java8新增的Collection.removeIf(Predicate&lt;? super E&gt; filter)方法 12list.removeIf(o -&gt; \"a\".equals(o) || \"b\".equals(o));System.out.println(list); // [c]","link":"/2019/11/03/Java%E5%BE%AA%E7%8E%AF%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0/"},{"title":"MySQL之十万个为什么","text":"索引相关 CREATE INDEX 和 ALTER TABLE ADD INDEX的区别？ CREATE INDEX ‘idx’ ON table (column); 一次只能创建一个索引，索引名不能为空。 ALTER TABLE table ADD INDEX ‘idx1’ (column1), ADD INDEX ‘idx2’ (column2); 一次可以创建多个索引，索引名可以为空（这时索引名默认取字段名，聚合索引默认取第一个字段名）。 COUNT(*) 和 COUNT(1)有什么区别 没区别（无论是执行计划，还是结果，还是性能） COUNT(*)作用是返回这张表的行数。 COUNT(1)作用是给所有行添加一个名为‘1’的虚拟的字段，然后统计这一字段的行数。 同理，COUNT(-1)和COUNT(100)和COUNT(‘a’)都是一样的。","link":"/2019/11/02/MySQL%E4%B9%8B%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88/"},{"title":"SpringBoot系列：AOP","text":"什么是AOPAOP，就是面向切面编程，在维基百科上是这样描述的： 面向切面的程序设计（Aspect-oriented programming，AOP，又译作面向方面的程序设计、剖面導向程式設計）是计算机科学中的一种程序设计范型，旨在将横切关注点与业务主体进行进一步分离，以提高程序代码的模块化程度。通过在现有代码基础上增加额外的通知（Advice）机制，能够对被声明为“切点（Pointcut）”的代码块进行统一管理与装饰，如“对所有方法名以set开头的方法添加后台日志”。该思想使得开发人员能够将与代码核心业务逻辑关系不那么密切的功能（如日志功能）添加至程序中，同时又不降低业务代码的可读性。面向切面的程序设计思想也是面向切面软件开发的基础。 开始首先准备一个简单的SpringBoot项目 Maven配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.skuldmoon.springboot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-aop&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-aop&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 编写controller层代码： 123456789101112131415161718192021package com.skuldmoon.springboot.aop.controller;import com.skuldmoon.springboot.aop.service.MyService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class MyController &#123; @Autowired private MyService myService; @GetMapping(\"/call\") public String call() &#123; String msg = \"Hello World!\"; myService.call(msg); return msg; &#125;&#125; 编写service层代码： 123456789101112package com.skuldmoon.springboot.aop.service;import org.springframework.stereotype.Service;@Servicepublic class MyService &#123; public void call(String msg) &#123; System.out.println(\"Call: \" + msg); &#125;&#125; 调用接口就能看到控制台输出： 1Call: Hello World! 切面编程在Maven配置文件中添加AOP的依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 编写aspect层代码：使用@Before和@After注解，分别代表在切点执行前后的切面，所以他们将会在切点方法执行前后执行。call(..)方法中的两个点代表任意个参数，可以是零个，一个，多个。 12345678910111213141516171819202122package com.skuldmoon.springboot.aop.aspect;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;@Aspect@Componentpublic class MyAspect &#123; @Before(\"execution(public void com.skuldmoon.springboot.aop.service.MyService.call(..))\") public void beforeCall() &#123; System.out.println(\"Before call\"); &#125; @After(\"execution(public void com.skuldmoon.springboot.aop.service.MyService.call(..))\") public void afterCall() &#123; System.out.println(\"After call\"); &#125;&#125; 调用接口，输出： 123Before callCall: Hello World!After call 使用@Around注解，@Around注解可以同时实现@Before和@After的功能，但是需要在代码中执行切点方法，即调用ProceedingJoinPoint.proceed()方法。注意：如果不调用此方法，切点方法是不会执行的！ 123456789101112131415161718192021package com.skuldmoon.springboot.aop.aspect;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.springframework.stereotype.Component;@Aspect@Componentpublic class MyAspect &#123; @Around(\"execution(public void com.skuldmoon.springboot.aop.service.MyService.call(..))\") public Object aroundCall(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(\"Around start\"); Object result = pjp.proceed(); System.out.println(result); System.out.println(\"Around end\"); return result; &#125;&#125; 调用接口，输出：中间输出null是因为切点方法call()没有返回值。 1234Around startCall: Hello World!nullAround end 可以使用@Pointcut注解来声明一个切点，这样其他切面直接使用这个切点，不用每次都写一长串的切点表达式。可以使用*通配所有的返回值。@AfterThrowing注解是在切点方法抛出异常之后执行，所以这里没有输出。 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.skuldmoon.springboot.aop.aspect;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;@Aspect@Componentpublic class MyAspect &#123; @Pointcut(\"execution(* com.skuldmoon.springboot.aop.service.MyService.call(..))\") public void pointCut() &#123;&#125; @Before(\"pointCut()\") public void beforeCall() &#123; System.out.println(\"Before call\"); &#125; @After(\"pointCut()\") public void afterCall() &#123; System.out.println(\"After call\"); &#125; @AfterReturning(\"pointCut()\") public void afterCallReturning() &#123; System.out.println(\"After call returning\"); &#125; @AfterThrowing(\"pointCut()\") public void afterCallThrowing() &#123; System.out.println(\"After call throwing\"); &#125; @Around(\"pointCut()\") public Object aroundCall(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(\"Around start\"); Object result = pjp.proceed(); System.out.println(result); System.out.println(\"Around end\"); return result; &#125;&#125; 调用接口，输出： 1234567Around startBefore callCall: Hello World!nullAround endAfter callAfter call returning 如果想对参数进行处理，可以使用ProceedingJoinPoint.proceed(Object[] var1)方法来修改入参。 1234567891011121314151617181920212223package com.skuldmoon.springboot.aop.aspect;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;@Aspect@Componentpublic class MyAspect &#123; @Pointcut(\"execution(public void com.skuldmoon.springboot.aop.service.MyService.call(..))\") public void pointCut() &#123;&#125; @Around(\"pointCut()\") public Object aroundCall(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(\"Around start\"); Object result = pjp.proceed(new Object[]&#123;\"No Hello World!\"&#125;); System.out.println(result); System.out.println(\"Around end\"); return result; &#125;&#125; 调用接口，输出： 1234Around startCall: No Hello World!nullAround end","link":"/2019/11/09/SpringBoot%E7%B3%BB%E5%88%97%EF%BC%9AAOP/"},{"title":"Windows下提高效率的工具","text":"趁着今天有空，整理了一下我在Windows下用到的一些提高效率的工具 EverythingEverything是一个全局搜索的软件，是我用过的搜索速度最快的软件，搜索电脑中任何的文件都是毫秒级的反应速度。 AutoHotKeyAutoHotKey是一个自定义按键脚本的软件（所谓的‘宏’），可以将按键改成其他任意的一个按键，或者是多个按键同时点击。 比如说我的笔记本PrintScreen和Insert是在同一个按键上，而且默认启用的是PrintScreen，如果要使用Insert键，则需要在按住Fn键的同时再按PrintScreen键，在进行复制（粘贴）的时候就非常的麻烦，要按三个键，Ctrl+Fn+PrintScreen（Shift+Fn+PrintScreen）。 而使用AutoHotKey之后就可以将Ctrl+PrintScreen改成Ctrl+Insert了,脚本很简单，几行就搞定了： 12345678910111213141516;左Ctrl+PS -&gt; Ctrl+Ins&lt;^PrintScreen::^Insreturn;左Shift+PS -&gt; Shift+Ins&lt;+PrintScreen::+Insreturn;左Alt+PS -&gt; Alt+Ins&lt;!PrintScreen::!Insreturn;左Win+s -&gt; 打开Everything&lt;#s::Run,C:\\Program Files\\Everything\\Everything.exereturn 最后再将脚本放到C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp目录下就能开机启动了。","link":"/2019/10/26/Windows%E4%B8%8B%E5%BF%85%E5%A4%87%E8%BD%AF%E4%BB%B6/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/10/26/hello-world/"},{"title":"Windows+Idea+Gradle中文乱码解决办法","text":"最近想学习一下使用gradle来构建项目，于是使用Spring Initializr生成了一个Springboot+gradle的demo项目，发现中文会出现乱码的情况，而同样在这里生成的maven项目却没有这个问题。后来发现这是因为gradle默认会使用系统的编码来编译文件，文件是UTF-8编码，而Windows是GBK编码，所以编译后就出现了乱码。 下面是我整理的一些解决这个问题的办法。 修改idea设置依次点击顶部菜单上的help -&gt; Edit Custom VM Options，然后在文件中添加以下内容并重启idea。 1-Dfile.encoding=UTF-8 修改gradle配置打开项目中的build.gradle文件，在文件中添加以下内容并点击Import changes使修改生效。 123compileJava &#123; options.encoding = \"UTF-8\"&#125;","link":"/2019/10/27/Windows+Idea+Gradle%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"title":"Windows下安装MySQL","text":"下载mysql-5.7.23-winx64.zip mysql-8.0.18-winx64.zip 安装将下载的压缩包解压（我这里下载的是5.7的版本），然后在系统环境变量中添加MySQL解压出来的bin目录。 以管理员身份运行cmd，运行下面的命令： 123mysqld -installmysqld --initializenet start mysql 这样就安装并启动成功了（如果提示dll找不到，则下载DirectX修复工具进行修复）。 配置还是在cmd中输入命令： 1mysql -u root -p 系统提示我们输入密码，直接回车，这时候肯定登录失败，然后我们打开解压MySQL的目录，能看到一个.err格式的文件，用文本编辑器打开，就能看到初始密码，然后就可以使用这个密码登录了。 创建数据表下面创建数据库和表。 需要注意的是，数据库名和字段名使用``反引号引用，而注释是使用‘’单引号引用。 创建数据库： 1CREATE DATABASE `test` CHARSET 'utf8'; 创建表： 1234567CREATE TABLE `user` (`id` bigint(20) NOT NULL COMMENT 'id',`name` varchar(50) NOT NULL COMMENT 'name',`phone` varchar(50) NOT NULL COMMENT 'phone',PRIMARY KEY (`id`) USING BTREE,KEY(`name`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 ROW_FORMAT = Dynamic COMMENT = 'user';","link":"/2019/11/02/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/"}],"tags":[],"categories":[]}